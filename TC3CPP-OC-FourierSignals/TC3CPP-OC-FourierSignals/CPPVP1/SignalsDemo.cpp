///////////////////////////////////////////////////////////////////////////////
// SignalsDemo.cpp
#include "TcPch.h"
#pragma hdrstop

#include "SignalsDemo.h"
#include "CPPVP1Version.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// CSignalsDemo
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module CSignalsDemo
BEGIN_INTERFACE_MAP(CSignalsDemo)
	INTERFACE_ENTRY_ITCOMOBJECT()
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITComOnlineChange, ITComOnlineChange)
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
///</AutoGeneratedContent>
END_INTERFACE_MAP()

IMPLEMENT_IPERSIST_LIB(CSignalsDemo, VID_CPPVP1, CID_CPPVP1CSignalsDemo)
IMPLEMENT_ITCOMOBJECT(CSignalsDemo)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CSignalsDemo)


///////////////////////////////////////////////////////////////////////////////
// Set parameters of CSignalsDemo 
BEGIN_SETOBJPARA_MAP(CSignalsDemo)
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	SETOBJPARA_VALUE(PID_SignalsDemoParameter, m_Parameter)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of CSignalsDemo 
BEGIN_GETOBJPARA_MAP(CSignalsDemo)
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	GETOBJPARA_VALUE(PID_SignalsDemoParameter, m_Parameter)
///</AutoGeneratedContent>
END_GETOBJPARA_MAP()


///////////////////////////////////////////////////////////////////////////////
CSignalsDemo::CSignalsDemo()
	: m_Trace(m_TraceLevelMax, m_spSrv)
{
///<AutoGeneratedContent id="MemberInitialization">
	m_TraceLevelMax = tlAlways;
	memset(&m_Parameter, 0, sizeof(m_Parameter));
	m_pOutputs = NULL;
///</AutoGeneratedContent>
}

///////////////////////////////////////////////////////////////////////////////
CSignalsDemo::~CSignalsDemo() 
{
}


///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(CSignalsDemo)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT CSignalsDemo::SetObjStatePS(PTComInitDataHdr pInitData)
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);

	// query TcCOM object server for ITcADI interface with own object id, 
	// which retrieves a reference to the TMC module instance handler
	m_spADI.SetOID(m_objId);
	hr = FAILED(hr) ? hr : m_spSrv->TcQuerySmartObjectInterface(m_spADI);

	// TODO: Add initialization code

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT CSignalsDemo::SetObjStateSO()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

	// Retrieve pointer to data areas via ITcADI interface from TMC module handler
///<AutoGeneratedContent id="DataAreaPointerInitialization">
	hr = FAILED(hr) ? hr : m_spADI->GetImagePtr(sizeof(SignalsDemoOutputs), 0, ADI_SignalsDemoOutputs, (PVOID*)(&m_pOutputs));
///</AutoGeneratedContent>

	// TODO: Add any additional initialization

	// Cleanup if transition failed at some stage
	if ( FAILED(hr) )
	{
		SetObjStateOS();
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT CSignalsDemo::SetObjStateOS()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;

	// Release pointer to data areas via ITcADI interface from TMC module handler
///<AutoGeneratedContent id="DataAreaPointerRelease">
	safe_release_imgptr(m_spADI, m_pOutputs);
///</AutoGeneratedContent>

	// TODO: Add any additional deinitialization

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT CSignalsDemo::SetObjStateSP()
{
	HRESULT hr = S_OK;
	m_Trace.Log(tlVerbose, FENTERA);

	m_spADI = NULL;

	// TODO: Add deinitialization code

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///<AutoGeneratedContent id="ImplementationOf_ITComOnlineChange">
///////////////////////////////////////////////////////////////////////////////
// PrepareOnlineChange is called after this instance has been set to PREOP in non RT context. 
// Parameter ipOldObj refers to the currently active instance which is still in OP. 
// Retrieve parameter values that are not changed during OP via ipOldObj here.
// 
// Parameter pOldInfo refers to instance data which includes the libraryId and
// the module class id. This information can be used to implement switch from one 
// specific version to another.
HRESULT CSignalsDemo::PrepareOnlineChange(ITComObject* ipOldObj, TmcInstData* pOldInfo)
{
	HRESULT hr = S_OK;

	ULONG nData = sizeof(m_Parameter);
	PVOID pData = &m_Parameter;
	ipOldObj->TcGetObjPara(PID_SignalsDemoParameter, nData, pData);

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// PerformOnlineChange is called after this instance has been set to SAFEOP in RT context.
// Parameter ipOldObj refers to old instance which is now in SAFEOP. 
// Allows to retrieve data after the last cyclic update of the old instance and
// before the first cyclic update of this instance.
HRESULT CSignalsDemo::PerformOnlineChange(ITComObject* ipOldObj, TmcInstData* pOldInfo)
{
	HRESULT hr = S_OK;
	

	return hr;
}
///</AutoGeneratedContent>


///<AutoGeneratedContent id="ImplementationOf_ITcCyclic">
HRESULT CSignalsDemo::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
	HRESULT hr = S_OK;

	// Cylce time in nanoseconds, i.e. time between "begin of task" to next "begin of task" (configured information)
	hr = FAILED(hr) ? hr : ipTask->GetCycleTime(&m_pOutputs->TaskCycleTime);
	_TaskTime = m_pOutputs->TaskCycleTime / 1000000.0;

	// Type of signal to generate
	SignalType = Pulse;

	// Run calculation and return output
	m_pOutputs->Value = GenerateSignal(harmonics, amplitude, frequency);

	return hr;
}
///</AutoGeneratedContent>

double CSignalsDemo::GenerateSignal(int harmonics, double amplitude, double frequency)
{
	double _fsCalculation = 0.0;
	double _theta = 0.0;
	int Index = 0;

	_theta = CalcTheta(frequency);

	for (Index = 1; Index < harmonics + 1; Index++)
	{
		_fsCalculation = _fsCalculation + ((CalcCoefficient(Index) * (amplitude * (sin_(Index * _theta)))) * PI);
	}

	return _fsCalculation;
}

double CSignalsDemo::CalcTheta(double frequency)
{
	double _timeBase = 0;
	double _maxTheta = 0;
	double _stepSize = 0;

	// Calculate Theta
	_timeBase = ((1.0 / frequency) * 1000.0) / this->_TaskTime;
	_maxTheta = (360.00 * (PI / 180.0));
	_stepSize = _maxTheta / _timeBase;

	if (this->_Theta == _maxTheta)
		this->_Theta = _stepSize;
	else if (this->_Theta > _maxTheta)
		this->_Theta = (this->_Theta - _maxTheta) + _stepSize;
	else
		this->_Theta = this->_Theta + _stepSize;

	return this->_Theta;
}

double CSignalsDemo::CalcCoefficient(int N) {

	double first = 0.01;
	double second = 0.01;
	double temp;

	switch (SignalType) 
	{
		case Square:
			if (((N + 1) % 2) == 0)
				return 1 / (N * 1.00);
			else
				return 0;
			break;

		case Sawtooth:
			if(N % 2 == 1)
				return -1 / ((N * 1.0) + 1);
			else
				return 1 / ((N * 1.0) + 1);
			break;

		case Triangle:
			if (N % 2 == 0) 
			{
				return 0;
				break;
			}
			if(N % 4 == 1)
				return(1 / (N * N * 1.0));
			else
				return (-1 / (N * N * 1.0));
			break;

		case Fibonacci:
			for (int i = 0; i < N; i++)
			{
				temp = first + second;
				first = second;
				second = temp;
			}
			return temp;
			break;

		case Pulse:
			return 0.1;
			break;

		default:
			if (((N + 1) % 2) == 0)
				return 1 / (N * 1.00);
			else
				return 0;
	}
}

